{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/p/4a17b156.html"},{"title":"test","text":"","link":"/p/d87f7e0c.html"},{"title":"记录一次线上服务事故","text":"前言最近两天某个项目的认定模块总是出现问题，好几个老师群里反馈，后面小组成员排查了一下发现是Redis key过期回调没有触发。 先说一下我们这个服务的逻辑，当某个活动被启用时，会自动创建一个缓存，ttl为现在时间距离活动开始时间的长度，然后当key过期时，会自动触发RedisKeyExpirationListener 里面的onMessage，然后再去实现具体的业务。 一直以来Prod和Dev一直是可以正常使用的，然后最近才出现这个问题。 一开始以为是某些活动没有触发到，今天仔细一看是所有都没有触发出来！！ 于是我们就慌了，后面看了一下发现是Redis的某个配置没有开启，就是这个：notify-keyspace-events Ex。 但是又很奇怪，为什么之前一直可以？最近才会出现这个问题呢？（等大佬解答 上图，默认是没有开启这个回调事件的。 于是暂停了SpringBoot服务，然后重新配置了一下Redis，再一顿重启，终于搞定。（图示是我另外一个也是用到这个的模块 太多坑了，有个小伙伴提转MQ异步消费，感觉更稳定！","link":"/p/c5eeaec6.html"},{"title":"博客使用B2+CF作为图床","text":"最近博客转为hexo搭建啦，完全静态博客！但是这个图片存储着实让我头疼。 在14年的适合，陆陆续续使用过又拍云和七牛云。 然后七牛那时候还是有临时链接的，只是用着用着突然就没办法用要绑定自己的域名， 刚好那时候是在运营vpao.net，然后就绑定了上去，一直到高一，就没怎么管博客了。 等高考结束后，我才发现我的vpao.net被污染了，这让我很想不通，我又不是什么违规站点， 一直到现在，都是处于污染状态，域名我可是从17年续费到24年啊！ 说远了，虽然现在七牛还有容量，但是没有备案域名也绑定不了。 昨天一直在找存储方案，发现好像可以使用Backblaze进行存储，有免费10GB容量，可通过CloudFlare自定义域名。 虽然对亚太地区不太友好，等有钱了就换国内OSS！ 找了一圈，跟着一位大佬部署了一下，完美搞定~ 有需要的可以看，使用PicGo+CF(Cloudflare)+B2(Backblaze)作为博客图床 顺便说一下博客介绍，一切都是白嫖的 域名，工作室某个师姐友情赠送 博客运行在Vercael 代码存储在Github 评论使用MongoDB免费版存储 图片存储使用Backblaze + CloudFlare 写作使用免费版typora + picgo 暂无其他说明","link":"/p/40faba9d.html"},{"title":"面试官：怎么设计一个部门表？","text":"需求昨天面试遇到的一个问题，要构建一个部门表，基础字段有部门名、部门id。 问，怎么设计这个部门？如果要你写一条SQL，根据部门ID查询出直接子部门和非直接子部门，那要怎么设计？多少个表？ 解决方案表结构设计 123456CREATE TABLE dept ( dept_id INT AUTO_INCREMENT PRIMARY KEY, dept_name VARCHAR(50) NOT NULL, parent_id INT, ancestors VARCHAR(255)); 解释，ancestors 存放的是祖宗的主键值，主要是用来存放本部门的祖宗的。 1234567891011假设部门的关系如下：- A部门: ID=1- B部门: ID=2（父部门是A）- C部门: ID=3（父部门是B）在这种情况下，部门的`ancestors`字段会设置为：- A部门的`ancestors`为空，因为它是顶级部门。- B部门的`ancestors`为`1`，表示A是B的直接上级。- C部门的`ancestors`为`1,2`，表示A是C的顶级上级，B是C的直接上级。 这样子做的好处是，查询直接子部门和非直接子部门只需要遍历这个ancestors 即可，无需借助其他的。如果没有ancestors的帮助，我们需要在代码中通过parent_id逐层逐级的遍历列举以及合并列表。查询的sql也只需要这样子。 12345select * from deptWHERE dept_id IN ( SELECT dept_id FROM dept WHERE find_in_set('查询的ID', ancestors ) )# FIND_IN_SET('2', ancestors) 就是在 ancestors 字段中查找是否存在 '2'，# 如果存在，返回其位置（非零值）。 缺点每次维护表的时候，都要专门去维护ancestors 这个节点，会加大维护成本","link":"/p/4c646377.html"},{"title":"RabbitMq 点击Exchanges出现Management API returned status code 500错误解决方法","text":"前言最近项目部署RabbitMQ中间件，使用DEV服务器安装的mq在图形化界面点击Exchanges交换机的时候出现 “Management API returned status code 500 -” 的错误，对于已经很久没玩mq的我有点懵逼。 搜索了一圈，发现新的版本好像默认会关闭UI数据分析可视化查询，然后进去容器里面追加一个配置重启就可以了。 教程首先进入自己的mq容器 docker exec -it rabbitmq /bin/bash 进入到容器以后cd到这个目录，**/etc/rabbitmq/conf.d/** 然后执行这个命令， echo management_agent.disable_metrics_collector = false &gt; management_agent.disable_metrics_collector.conf 重启你的mq容器 docker restart rabbitmq 然后就可以啦！ 写在后面rabbitMq好久没接触过，都忘了怎么玩了，有时间重新学习一下！写这个文章是为了作一下记录，避免以后遇到同样的问题。 而且其实我还有疑问的，为什么我线上部署的版本不用关闭这个也不会出现这样子的错误呢？有时间研究… 借鉴 【RabbitMQ】之解决后台管理页面 Channels 报错提示 RabbitMQ在Docker中安装以及Management API returned status code 500错误)","link":"/p/352b77f0.html"},{"title":"分布式事务2pc和tcc的理解","text":"前言转载自下面的文章，很容易理解，先保留一下，后面再继续完善https://www.upyun.com/opentalk/332.html 事务模式 -两阶段提交(2PC)事物模式的代表就是两阶段提交，它的含义就是每个服务有自己的子事务，服务之间其实也是通过分布式事务来保障事务的一致性。 所以它在第一阶段的时候，这个协调器会发一个propose的请求给三个服务，如果每个服务都可以接受接下来的事务请求，它就会回复yes或者是no。回复之后就会到第二个阶段，如果前面三个服务回复的都是一个yes，那协调器就会发送commit这个请求，去执行这三个服务的事务操作，否则就会发送一个abort请求。执行完成之后，三个服务会回来一个ack，表示这个事务已经结束，或者是已经取消。 优点：有事务的原子性，因为在每次做事务操作的时候，都会锁定资源，所以所有进入协调器的请求，其实都是一个线性的请求，它不能去同步所有的事务。 缺点：它是一个阻塞式的模式，它需要锁定资源，它的复杂度也会相对比较高，比较难扩展。 预约模式 -TCC(Try-Confirm/Cancel)预约模式比较典型的叫Try-Confirm/Cancel，缩写就是TCC。它也是一个两阶段的模式。第一个阶段它会发一个try的请求给三个服务，如果三个服务可以执行，它们就会回复yes，不能回复no，这和两阶段面试官：怎么设计一个部门表？.md提交是一致的。不一样的地方是它不会锁定资源。所以在A处理完它的子事务，B可能还没有处理完它的子事务的时候，A可以接受其他的请求。在第二阶段，像两阶段提交一样，协调器会根据第一阶段ABC的返回结果去发送Confirm或者Cancel，这样的请求，最后ABC会返回ack。 优点：在try阶段如果失败，服务会回复至原状，什么意思呢？比如说要发一个会议邀请，如果用TCC的模式，第一阶段会先发一个询问的请求给所有的与会人员，询问是否可以在这一个时间点来参会，如果所有的参会人员都回答yes，第二步就会发送一个确认请求，实际的一个会议邀请，如果有任何一个人员不能参加，就会发送一个Cancel，取消这个会议。 缺点： 它不是原子操作，它可以并行处理好多的分布式的事务，然后它在Confirm这个阶段，只能重试，如果有一个服务失败的话，只能重试，直到成功，或者是采取回退措施，需要人工去做干预。 它需要一个额外的try流程，服务需要提供额外的try的结构，也就需要提供额外的reserved的状态。","link":"/p/6c1e1438.html"},{"title":"itextpdf+thymeleaf实现html转pdf","text":"业务需求项目需要用到导出pdf格式的列表，正常情况下是导出excel表格的，但是产品要求要导出pdf，组长叫我尝试一下itextpdf和thymeleaf。捣鼓了几天研究出来了，但是还没有具体运用上线。 教程最终效果如下图 准备POM依赖先导入相关的pom依赖 12345678910111213141516171819202122232425&lt;!-- itext7html转pdf --&gt;&lt;dependency&gt; &lt;groupId&gt;com.itextpdf&lt;/groupId&gt; &lt;artifactId&gt;html2pdf&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 中文字体支持 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.itextpdf&lt;/groupId&gt; &lt;artifactId&gt;font-asian&lt;/artifactId&gt; &lt;version&gt;7.1.13&lt;/version&gt;&lt;/dependency&gt;&lt;!--freemarker模板--&gt;&lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.8.16&lt;/version&gt;&lt;/dependency&gt; Handler这里主要是加一些适配器，比如页眉、页码、水印等 页眉相关1234567891011121314151617181920public class HeaderH implements IEventHandler { String header; public HeaderH(String header) { this.header = header; } @Override public void handleEvent(Event event) { PdfDocumentEvent docEvent = (PdfDocumentEvent) event; PdfDocument pdf = docEvent.getDocument(); PdfPage page = docEvent.getPage(); if (pdf.getPageNumber(page) == 1) return; Rectangle pageSize = page.getPageSize(); PdfCanvas pdfCanvas = new PdfCanvas( page.getLastContentStream(), page.getResources(), pdf); Canvas canvas = new Canvas(pdfCanvas, pdf, pageSize); canvas.showTextAligned(header, pageSize.getWidth() / 2, pageSize.getTop() - 30, TextAlignment.CENTER); }} 页码123456789101112131415161718192021222324252627282930313233343536373839public class PageXofY implements IEventHandler { protected PdfFormXObject placeholder; protected int totalPageCount; protected float side = 20; protected float x = 750; protected float y = 25; protected float space = 4.5f; protected float descent = 3; public PageXofY(PdfDocument pdf, int totalPageCount) { placeholder = new PdfFormXObject(new Rectangle(0, 0, side, side)); this.totalPageCount = totalPageCount; } @Override public void handleEvent(Event event) { PdfDocumentEvent docEvent = (PdfDocumentEvent) event; PdfDocument pdf = docEvent.getDocument(); PdfPage page = docEvent.getPage(); int pageNumber = pdf.getPageNumber(page); Rectangle pageSize = page.getPageSize(); PdfCanvas pdfCanvas = new PdfCanvas( page.getLastContentStream(), page.getResources(), pdf); Canvas canvas = new Canvas(pdfCanvas, pdf, pageSize); Paragraph p = new Paragraph() .add(&quot;Page&quot;) .add(String.valueOf(StrPool.C_SPACE)) .add(String.valueOf(pageNumber)) .add(String.valueOf(StrPool.C_SPACE)) .add(&quot;of&quot;) .add(String.valueOf(StrPool.C_SPACE)) .add(String.valueOf(totalPageCount)); canvas.showTextAligned(p, x, y, TextAlignment.RIGHT); pdfCanvas.addXObject(placeholder, x + space, y - descent); pdfCanvas.release(); }} 水印1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * 水印 */public class WaterMarkEventHandler implements IEventHandler{ /** * 水印内容 */ private String waterMarkContent; /** * 一页中有几列水印 */ private int waterMarkX; /** * 一页中每列有多少水印 */ private int waterMarkY; public WaterMarkEventHandler(String waterMarkContent) { this(waterMarkContent, 5, 5); } public WaterMarkEventHandler(String waterMarkContent, int waterMarkX, int waterMarkY) { this.waterMarkContent = waterMarkContent; this.waterMarkX = waterMarkX; this.waterMarkY = waterMarkY; } @Override public void handleEvent(Event event) { PdfDocumentEvent documentEvent = (PdfDocumentEvent) event; PdfDocument document = documentEvent.getDocument(); PdfPage page = documentEvent.getPage(); Rectangle pageSize = page.getPageSize(); PdfFont pdfFont = null; try { pdfFont = PdfFontFactory.createFont(&quot;STSongStd-Light&quot;, &quot;UniGB-UCS2-H&quot;, false); } catch (IOException e) { e.printStackTrace(); } PdfCanvas pdfCanvas = new PdfCanvas(page.newContentStreamAfter(), page.getResources(), document); Paragraph waterMark = new Paragraph(waterMarkContent).setOpacity(0.5f); Canvas canvas = new Canvas(pdfCanvas, pageSize) .setFontColor(WebColors.getRGBColor(&quot;lightgray&quot;)) .setFontSize(16) .setFont(pdfFont); for (int i = 0; i &lt; waterMarkX; i++) { for (int j = 0; j &lt; waterMarkY; j++) { canvas.showTextAligned(waterMark, (150 + i * 300), (160 + j * 150), document.getNumberOfPages(), TextAlignment.CENTER, VerticalAlignment.BOTTOM, 120); } } canvas.close(); }} UtilsFreeMarkerUtils123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class FreeMarkerUtils{ private static Template getTemplate(String template_path, String templateFileName) { Configuration configuration = new Configuration(); Template template = null; try { configuration.setDirectoryForTemplateLoading(new File(template_path)); configuration.setObjectWrapper(new DefaultObjectWrapper()); configuration.setDefaultEncoding(&quot;UTF-8&quot;); //设置编码格式 //模板文件 template = configuration.getTemplate(templateFileName + &quot;.ftl&quot;); } catch (IOException e) { e.printStackTrace(); } return template; } public static void genteratorFile(Map&lt;String, Object&gt; input, String template_path, String templateFileName, String savePath, String fileName) { Template template = getTemplate(template_path, templateFileName); File filePath = new File(savePath); if (!filePath.exists()) { filePath.mkdirs(); } String filename = savePath + &quot;\\\\&quot; + fileName; File file = new File(filename); if (!file.exists()) { file.delete(); } Writer writer = null; try { writer = new OutputStreamWriter(new FileOutputStream(filename), &quot;UTF-8&quot;); template.process(input, writer); } catch (Exception e) { e.printStackTrace(); } } public static String genterator(Map&lt;String, Object&gt; variables, String template_path, String templateFileName) throws Exception { Template template = getTemplate(template_path, templateFileName); StringWriter stringWriter = new StringWriter(); BufferedWriter writer = new BufferedWriter(stringWriter); template.setEncoding(&quot;UTF-8&quot;); template.process(variables, writer); String htmlStr = stringWriter.toString(); writer.flush(); writer.close(); return htmlStr; }} HtmlToPdfUtils123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160public class HtmlToPdfUtils { /** * html转pdf * * @param inputStream 输入流 * @param waterMark 水印 * @param fontPath 字体路径，ttc后缀的字体需要添加&lt;b&gt;,0&lt;b/&gt; * @param outputStream 输出流 * @date : 2022/11/15 14:07 */ public static void convertToPdf(InputStream inputStream, String waterMark, String fontPath, OutputStream outputStream) throws IOException { // 有两个pdfWriter和pdfDocument是因为为了解决这个页码的问题， // 原先页码是没办法获取到总的页码数量，经过一顿骚操作改造可以了，但是不知道会不会有隐藏风险 PdfWriter pdfWriter = new PdfWriter(outputStream); PdfWriter pdfWriter1 = new PdfWriter(outputStream); PdfDocument pdfDocument = new PdfDocument(pdfWriter); PdfDocument pdfDocument1 = new PdfDocument(pdfWriter1); // 设置为A4大小并设置横向// PageSize pageSize = PageSize.A4.rotate(); pdfDocument.setDefaultPageSize(PageSize.A4.rotate()); pdfDocument1.setDefaultPageSize(PageSize.A4.rotate()); // 如果是纵向就用下面这个// pdfDocument.setDefaultPageSize(PageSize.A4);// pdfDocument1.setDefaultPageSize(PageSize.A4); // 添加水印 pdfDocument.addEventHandler(PdfDocumentEvent.END_PAGE, new WaterMarkEventHandler(waterMark)); // 添加中文字体支持 ConverterProperties properties = new ConverterProperties(); FontProvider fontProvider = new FontProvider(); // 添加自定义字体， if (!StringUtils.isEmpty(fontPath)) { // 下面是使用的鸿蒙字体 String HARMONYOS_SANS_SC_REGULAR = &quot;D:\\\\lot\\\\code\\\\study\\\\springboot-restful-starter\\\\src\\\\main\\\\resources\\\\fonts\\\\HARMONYOS_SANS_SC_REGULAR.TTF&quot;; String HARMONYOS_SANS_SC_BOLD = &quot;D:\\\\lot\\\\code\\\\study\\\\springboot-restful-starter\\\\src\\\\main\\\\resources\\\\fonts\\\\HARMONYOS_SANS_SC_BOLD.TTF&quot;; String HARMONYOS_SANS_SC_BLACK = &quot;D:\\\\lot\\\\code\\\\study\\\\springboot-restful-starter\\\\src\\\\main\\\\resources\\\\fonts\\\\HARMONYOS_SANS_SC_BLACK.TTF&quot;; PdfFont ttfFontOne = PdfFontFactory.createFont(HARMONYOS_SANS_SC_REGULAR, PdfEncodings.IDENTITY_H, false); PdfFont ttfFontTwo = PdfFontFactory.createFont(HARMONYOS_SANS_SC_BOLD, PdfEncodings.IDENTITY_H, false); PdfFont ttfFontThird = PdfFontFactory.createFont(HARMONYOS_SANS_SC_BLACK, PdfEncodings.IDENTITY_H, false); fontProvider.addFont(ttfFontOne.getFontProgram()); fontProvider.addFont(ttfFontTwo.getFontProgram()); fontProvider.addFont(ttfFontThird.getFontProgram()); properties.setFontProvider(fontProvider); properties.setCharset(&quot;utf-8&quot;); } properties.setFontProvider(fontProvider); // 读取Html文件流，查找出当中的&amp;nbsp;或出现类似的符号空格字符 Map&lt;String, Object&gt; map = readInputStrem(inputStream); // 需要先生成document，而不是直接生成pdf文件（因直接生成pdf文件会关闭流） Document document = HtmlConverter.convertToDocument((String) map.get(&quot;html&quot;), pdfDocument1, properties); document.flush(); PageXofY event = new PageXofY(pdfDocument, document.getPdfDocument().getNumberOfPages()); pdfDocument.addEventHandler(PdfDocumentEvent.END_PAGE, event); inputStream = (InputStream) map.get(&quot;inputStream&quot;); try { if (inputStream != null) { // 生成pdf文档 HtmlConverter.convertToPdf(inputStream, pdfDocument, properties); return; } else { log.error(&quot;转换失败！&quot;); } } catch (Exception e) { e.printStackTrace(); } finally { try { pdfWriter.close(); pdfDocument.close(); } catch (IOException e) { throw new RuntimeException(e); } } } /** * 读取HTML 流文件，并查询当中的&amp;nbsp;或类似符号直接替换为空格 * * @param inputStream * @return */ private static Map&lt;String, Object&gt; readInputStrem(InputStream inputStream) { HashMap&lt;String, Object&gt; returnMap = new HashMap&lt;&gt;(2); // 定义一些特殊字符的正则表达式 如： String regEx_special = &quot;\\\\&amp;[a-zA-Z]{1,10};&quot;; try { //&lt;1&gt;创建字节数组输出流，用来输出读取到的内容 ByteArrayOutputStream baos = new ByteArrayOutputStream(); //&lt;2&gt;创建缓存大小 byte[] buffer = new byte[1024]; // 1KB //每次读取到内容的长度 int len = -1; //&lt;3&gt;开始读取输入流中的内容 while ((len = inputStream.read(buffer)) != -1) { //当等于-1说明没有数据可以读取了 baos.write(buffer, 0, len); //把读取到的内容写到输出流中 } //&lt;4&gt; 把字节数组转换为字符串 String content = baos.toString(); //&lt;5&gt;关闭输入流和输出流 // inputStream.close(); baos.close(); // log.info(&quot;读取的内容：{}&quot;, content); // 判断HTML内容是否具有HTML的特殊字符标记 Pattern compile = Pattern.compile(regEx_special, Pattern.CASE_INSENSITIVE); Matcher matcher = compile.matcher(content); String replaceAll = matcher.replaceAll(&quot;&quot;); // log.info(&quot;替换后的内容：{}&quot;, replaceAll); // 将字符串转化为输入流返回 InputStream stringStream = getStringStream(replaceAll); returnMap.put(&quot;inputStream&quot;, stringStream); returnMap.put(&quot;html&quot;, replaceAll); //&lt;6&gt;返回结果 return returnMap; } catch (Exception e) { e.printStackTrace(); log.error(&quot;错误信息：{}&quot;, e.getMessage()); return null; } } /** * 将一个字符串转化为输入流 * * @param sInputString 字符串 * @return */ public static InputStream getStringStream(String sInputString) { if (sInputString != null &amp;&amp; !sInputString.trim().equals(&quot;&quot;)) { try { ByteArrayInputStream tInputStringStream = new ByteArrayInputStream(sInputString.getBytes()); return tInputStringStream; } catch (Exception e) { e.printStackTrace(); } } return null; }} 测试类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127@Slf4jpublic class TestHtmlToPdf { // 模板路径 public final static String TEMP = &quot;D:\\\\lot\\\\code\\\\study\\\\springboot-restful-starter\\\\src\\\\main\\\\resources\\\\templates\\\\&quot;; /** * 模板所需的数据 * * @return 数据 */ public static Map&lt;String, Object&gt; getContent() { // 从数据库中获取数据， 出于演示目的， 这里数据不从数据库获取， 而是直接写死 Map input = new HashMap(); input.put(&quot;title&quot;, &quot;测试title&quot;); input.put(&quot;logo&quot;, &quot;&quot;); input.put(&quot;accountId&quot;, &quot;MC&quot; + UUID.randomUUID(false)); input.put(&quot;accountName&quot;, &quot;MC&quot; + UUID.randomUUID(false)); input.put(&quot;dateOfIssue&quot;, DateUtil.now()); List&lt;Map&lt;String, String&gt;&gt; tableData = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) { Map&lt;String, String&gt; rowData = new HashMap&lt;&gt;(); rowData.put(&quot;tableData1&quot;, &quot;这是第&quot; + (i + 1) + &quot;行的第一个表格数据行的第一个表格数据行的第一个表格数据行的第一个表格数据行的第一个表格数据行的第一个表格数据&quot;); rowData.put(&quot;tableData2&quot;, &quot;这是第&quot; + (i + 1) + &quot;行的第二个表格数据行的第一个表格数据行的第一个表格数据行的第一个表格数据行的第一个表格数据行的第一个表格数据行的第一个表格数据&quot;); tableData.add(rowData); } input.put(&quot;tableData&quot;, tableData); input.put(&quot;accountId&quot;, UUID.randomUUID()); input.put(&quot;DateOfIssue&quot;, DateUtil.today()); // 准备美国人的姓和名的数组 String[] firstNames = {&quot;James&quot;, &quot;John&quot;, &quot;Robert&quot;, &quot;Michael&quot;, &quot;William&quot;}; String[] lastNames = {&quot;Smith&quot;, &quot;Johnson&quot;, &quot;Williams&quot;, &quot;Jones&quot;, &quot;Brown&quot;}; // 使用RandomUtil随机选择姓和名 String randomFirstName = RandomUtil.randomEle(firstNames); String randomLastName = RandomUtil.randomEle(lastNames); // 组合姓名 String fullName = randomFirstName + &quot; &quot; + randomLastName; input.put(&quot;accountName&quot;, fullName); List&lt;Map&lt;String, Object&gt;&gt; rows = new ArrayList&lt;&gt;(); double y = 0; for (int i = 0; i &lt; 500; i++) { Random r = new Random(); DecimalFormat df = new DecimalFormat(&quot;#.##&quot;); String[] currencyArr = {&quot;USD&quot;, &quot;CNY&quot;, &quot;EURO&quot;}; String[] platformArr = {&quot;Shopify&quot;, &quot;WooCommerce&quot;, &quot;Magento&quot;}; String[] shipArr = {&quot;AFL SHIPPING&quot;, &quot;BFL SHIPPING&quot;, &quot;CFL SHIPPING&quot;}; String[] typeArr = {&quot;Deposit&quot;, &quot;Withdraw&quot;, &quot;Refund&quot;}; int minAmount = 20; int maxAmount = 1000; String date = &quot;2024-04-&quot; + r.nextInt(30); String demo1 = &quot;DemoDemoDemoDemoDemoDemoDemo&quot; + RandomUtil.randomNumbers(10); String demo2 = &quot;Demo&quot; + RandomUtil.randomNumbers(Integer.valueOf(RandomUtil.randomNumbers(1))); String accNumber = String.valueOf(r.nextLong()).substring(1, 14); String currency = currencyArr[r.nextInt(currencyArr.length)]; String platform = platformArr[r.nextInt(platformArr.length)]; String name = &quot;Ma Wang&quot; + RandomUtil.randomNumbers(10); String ship = shipArr[r.nextInt(shipArr.length)]; String quantity = String.valueOf(r.nextInt(30)); String type = typeArr[r.nextInt(typeArr.length)]; String amount = df.format(minAmount + (maxAmount - minAmount) * r.nextDouble()); Map&lt;String, Object&gt; row = new HashMap&lt;&gt;(); row.put(&quot;y&quot;, y); row.put(&quot;part1&quot;, date); row.put(&quot;part2&quot;, demo1); row.put(&quot;part3&quot;, demo2); row.put(&quot;part4&quot;, accNumber); row.put(&quot;part5&quot;, currency); row.put(&quot;part6&quot;, platform); row.put(&quot;part7&quot;, name); row.put(&quot;part8&quot;, ship); row.put(&quot;part10&quot;, currency); row.put(&quot;part11&quot;, quantity); row.put(&quot;part12&quot;, currency); row.put(&quot;part13&quot;, amount); row.put(&quot;part9&quot;, type); rows.add(row); y += 15; } input.put(&quot;rows&quot;, rows); return input; } public static void main(String[] args) throws IOException { extracted(&quot;thread-12&quot;); } private static void extracted(String filename) throws IOException { long startTime = System.currentTimeMillis(); String temp = &quot;test&quot;; // 指定模板渲染值并生成html文件至指定位置 FreeMarkerUtils.genteratorFile(getContent(), TEMP, temp, TEMP, temp + &quot;.html&quot;); // 需转换的html文件名称 String htmlFile = temp + &quot;.html&quot;; // 转换好pdf存储名称 String pdfFile = filename + &quot;.pdf&quot;; // 自定义水印 String waterMarkText = &quot;JYX&quot;; // 读取需转换的html文件 // 读取需转换的html文件 InputStream inputStream = new FileInputStream(TEMP + htmlFile); // 写出pdf存储位置 OutputStream outputStream = new FileOutputStream(TEMP + pdfFile); String FONT_TTF_PATH = &quot;D:\\\\lot\\\\code\\\\springboot-restful-starter\\\\src\\\\main\\\\resources\\\\fonts\\\\HARMONYOS_SANS_SC_REGULAR.TTF&quot;; // 开始转换html生成pdf文档 HtmlToPdfUtils.convertToPdf(inputStream, waterMarkText, FONT_TTF_PATH, outputStream); log.info(&quot;转换结束，耗时：{}ms&quot;, System.currentTimeMillis() - startTime); }} 模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; .a4-wrapper { width: 297mm; height: 210mm; padding: 20mm; box-sizing: border-box; background: white; } body { margin: 20px; font-family: Arial, sans-serif; } table { width: 100%; border-collapse: collapse; } th { border-bottom: 1px solid #d3d3d3; padding: 10px; text-align: left; margin-bottom: 20px; } td { border: none; padding: 10px; text-align: left; } .logo { display: block; margin-left: auto; margin-right: auto; width: 50%; } .title { text-align: center; margin-bottom: 20px; } .account-info { margin-left: 10%; } .date { margin-right: 10%; text-align: right; } .page { page-break-after: always; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;header&quot;&gt; &lt;div class=&quot;account-info&quot;&gt; &lt;img src=&quot;${logo!&quot;#&quot;}&quot; class=&quot;logo&quot; alt=&quot;Logo&quot;/&gt; &lt;h1 class=&quot;title&quot;&gt;${title!&quot;Title&quot;}&lt;/h1&gt; &lt;p&gt;Account ID: ${accountId!&quot;#&quot;}&lt;/p&gt; &lt;p&gt;Account Name: ${accountName!&quot;#&quot;}&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;date&quot;&gt; &lt;p&gt;Date of issue: ${dateOfIssue!&quot;#&quot;}&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;固定表头1&lt;/th&gt; &lt;th&gt;固定表头2&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;#list tableData as row&gt; &lt;tr&gt; &lt;td style=&quot;word-break: break-all; max-width: 100px;&quot;&gt;${row.tableData1}&lt;/td&gt; &lt;td style=&quot;word-break: break-all; max-width: 100px;&quot;&gt;${row.tableData2}&lt;/td&gt; &lt;/tr&gt; &lt;/#list&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;","link":"/p/6c1e1438.html"},{"title":"人大金仓创建Postgresql表并设置主键自增","text":"写在前面最近实习了，公司产品用的人大金仓，底层数据库是Postgresql。然后最近在建表，习惯了navicate，用这个一脸懵逼。而且因为需要设置主键自增，在可视化操作那里无法单独添加，很奇怪，会疯狂报错。我观察了其他大佬建的表，都是有一个nextval…啥的，谷歌了一波之后发现这是Postgresql的东西。所以得手动写sql，别人推荐的是加一个关键字就可以了，但是我的一直不可以，所以这个教程先记录一下手动建立序列的方法。 教程第一步 创建序列12345CREATE SEQUENCE 模式.table_name_id_seq; -- 查询select nextval('模式.table_name_id_seq'::regclass); 第二步 创建表12345CREATE TABLE 模式.sys_oper_sql_log ( id BIGINT PRIMARY KEY DEFAULT nextval('trs_cloud.sys_oper_sql_log_id_seq'::regclass), sql_content TEXT , oper_id BIGINT ); 方式二可以直接使用serial关键词来设定，默认id类型是integer，需要手动调整为bigint或者其他 123456789CREATE TABLE trs_cloud.lm_book_place ( id serial PRIMARY KEY , book_location varchar(50) , is_refuse_lend char default '0'::bpchar, create_by varchar(60), create_time timestamp without time zone, update_by varchar(60), update_time timestamp without time zone); 注意人大金仓不像Navicate一样，可视化插入，会提示报错，可能原因是他要先select那个nextval，然后可视化插入会提前先自检不能为空所以用insert into 实测可以用Navicate连接，操作虽然跟Mysql的不同，但是至少比人大金仓好太多，人大总是有奇奇怪怪的bug。 借鉴 https://blog.csdn.net/aaaaaaa1516682014292/article/details/128130697","link":"/p/d60be7ec.html"},{"title":"利用正则表达式在Vscode上去除空行、注释","text":"写在前面最近被软著搞到疯了，满60页代码、不能出现空行注释等情况。 代码均是在项目copy过来的，所以肯定是有空行和注释的，在word上可以一键去除空行，但是注释就有点麻烦。 于是想到把文字复制到Vscode上面，通过正则来去除这些。 然后6000多行的代码，去除空行和注释以后，剩下4000多，累了… 查询首先在vscode按住CTRL+H，然后输入下面的正则 选中全部查询的输入相对应的正则以后，应该就可以看到有匹配的，这时候就要选择多个查找出来的 去除注释单行注释1//[\\s\\S]*?\\n 块注释1/\\*(.|\\r\\n|\\n)*?\\*/ 所有注释1\\/\\*[\\s\\S]*\\*\\/|\\/\\/.* html注释1&lt;!--(.*?)--&gt; 去除空行1^\\s*(?=\\r?$)\\n 参照 Vscode 快捷操作_vscode删除一列_ (29条消息) VScode使用正则表达式快速删除注释","link":"/p/5623b276.html"},{"title":"用油猴脚本来自动填写问卷星的调查问卷，分分钟100+","text":"前言最近在写一份调查问卷，用问卷星系统进行填写调查报告，不过这个调查数据也挺水的，只要份数够就行了，所以我就想到可以利用脚本来自动填写问卷。其实之前也有用的Python写的脚本，但是感觉有时候挺麻烦的。 今天搜了一下发现一个很有用的油猴脚本，号称三分钟刷完100份问卷，测试了一下确实可以，但是为了模拟真人填写，我花了20分钟填了387份。想学吗？我教你啊！ 这个脚本食用起来需要一定的编程基础，不过按照我的教程来做，也可以自己搞定！再也不用求爷爷告奶奶去让别人填问卷啦！ 教程安装油猴这个直接浏览器安装插件就好了，根据自己对应的浏览器去安装。 Edge：Tampermonkey Chrome：Tampermonkey 之前在公众号也有写过安装油猴插件的文章，可以看看→[小白必看的油猴插件安装使用教程!!](小白必看的油猴插件安装使用教程!! (qq.com)) 安装脚本安装完油猴插件直接安装脚本就可以了。 油猴脚本：问卷星在线刷 (greasyfork.org) 进入脚本安装网页，点击下图这个按钮就可安装！ 安装好脚本，打开问卷星的问卷网站，看到这个提示，就说明脚本安装成功了，可以开搞了！ 编辑脚本信息安装完脚本以后，需要进入代码编辑页面进行题目答案以及比例的设置。 按照下图的步骤进入代码编辑页面。 进入代码编辑页面，往下滑就可以找到这个**// 定义自己问卷的 url** 的关键字，把下面网址替换成你的问卷星问卷的地址，注意不能把引号什么的搞掉，否则回报错无法运行。 下面的图示就是一种代码错误的提示，因为把网址左边的单引号去掉了，会导致编译时错误。 弄完网址以后，往下面滑下来就可以看到定义参数这个关键词，下面的代码就是来填写我们对应的问卷星题目的答案和答题比例。 参数解释：id代表题目的序号，type代表题目的列表，bili代表选项的比例。 比如：{id: 1, type: ‘单选’, bili: [30, 70]}, 解释：问题1有两个选项，类型是单选，两个选项的比例分别是30%和70%，需要保持选项比例加起来是100%，**多选每个选项都可以100%**。 注意：每个符号要前后匹配上，还有最后的英文逗号不能缺失。 其他类型也是如此，如果是填空，则需要多加一个content代表填空内容，cotent有多少个则bili就要对应多少个。 比如：问题9是填空类型，分别有两个可选的内容是哈哈哈、嘿嘿嘿，然后比例设置50%、50%，代表这两个选项内容的比例。 设置好代码以后，按住Ctrl+S就可以保存代码啦！ 返回问卷星页面，就可以开始愉快的自动化填写了。 错误解决方案有朋友经过安装、补充代码以后发现可以自动填写问题，但是无法自动提交等问题，以下是我对一些错误问题的解决方法，如果你也遇到这个问题，可以尝试跟着搞搞。 提交问卷的时候出现“点击按钮开始智能验证”提醒 默认脚本是没有开启这个点击按钮的，在脚本编辑页面按Ctrl + F 搜索layui-layer-btn0，对应下面的代码修改。 找到以后，对应增加下面的代码（注意不要放错位置）。 12345document.getElementById('SM_BTN_1').click()// 点击后会继续出现需要滑动滑块验证，所以7秒后会自动验证setTimeout(()=&gt;{ slidingSlider();},7000) 对照 按住Ctrl+S可以保存代码。 如果脚本正常运行，流程应该是：开始-随机填写问卷-自动点击提交按钮-自动点击智能验证-等待7秒钟-自动验证滑块-结束。 出现“ 哎呀，出错了 ，点击刷新再来一次(error:n7f0e)”，错误 在代码页面滑到最后，可以看到如下代码，根据下图提示来粘贴复制的代码。 同样在脚本编辑页面按Ctrl + F 搜索 slidingSlider，把函数替换成下面这样子。 12345678910setTimeout(()=&gt;{ // 出现哎呀出错啦，点击刷新再来一次错误 需要重新点击 var nc_1_refresh1_reject = document.getElementById('nc_1_refresh1') if(nc_1_refresh1_reject!=='undefined' || nc_1_refresh1_reject!==null){ nc_1_refresh1_reject.click() setTimeout(()=&gt;{ slidingSlider() },1000) } },1000) 出现”验证失败，请再次点击按钮刷新“错误 这时候需要关闭浏览器然后重新打开问卷，有条件的话更换一下ip。 写在后面先说说这个脚本，真的很有用，以前还不懂的时候，经常是求好多人帮忙去填写这个问卷，甚至去花钱叫别人来刷。而且填写这个问卷也是一个任务而已，不需要质，只需要量。 后面了解了脚本技术以后，就尝试着使用脚本来解放双手等等，今天这个问卷星就用上啦！不过这些脚本都是别的大佬写的，我只是作为一个使用者。 如果你需要数据真实准确，我不建议你使用脚本，也不提倡你使用这个去盈利，脚本是用来学习和便捷我们生活的，不要做违法的事情哦！如果在尝试的过程中遇到问题，可以在后天私聊我，我看到会回复并给出解决方案。 今天就分享到这里，有什么推荐或者想要的软件/网站/资源，欢迎后台留言！","link":"/p/9a4d61d1.html"},{"title":"vue3的el-form表单输入响应式失效问题（input、单选都无法操作）","text":"写在前面刚到公司，摸一下鱼。昨天朋友问了我一个vue3的一个对话框里面input框和单选框都无法输入或者选中，看了代码也没有禁用啥的操作。一切都正常，最后疯狂开启谷歌，发现命名冲突问题了。 教程 从上面可以看到，响应式的名字与model的名字一样，导致了冲突，所以就会出现输入框无法输入，选择框无法选择问题。 解决方法：修改名字为不同即可！","link":"/p/cee62a0f.html"},{"title":"RabbitMQ入门学习","text":"一、MQ入门1.1 消息中间件的协议1. AMQP协议 分布式事务； 消息的持久化； 高性能、高可靠的处理优势； 2. MQTT协议 物联网的重要组成部分。 低延迟、低带宽、不支持事务 3. OpenMessage协议 RocketMQ采用的协议。国内的阿里、雅虎等公司一起创作。 支持事务，持久化 4. Kafka协议 基于TCP/IP协议，采用二进制进行传输。 结构简单，不支持事务，支持持久化 1.2 消息分发机制 ActiveMQ RabbitMQ Kafka RocketMQ 发布订阅 √ √ √ √ 轮询分发 √ √ √ 公平分发 √ √ 重发 √ √ √ 消息拉取 √ √ √ 轮询分发、公平分发它们都是保证消息只能够读取一次。 轮询分发：每个消费者消费的消息总数量是一致的； 公平分发：能者多劳，消费者性能好，处理的请求就会比较多；必须手动应答，不支持自动应答 1.3 消息的高可用集群模式1：Master-Slave：主从共享数据生产者将消息发送到主节点，所有的都节点连接这个消息队列共享这块的数据区域。主节点写入，一旦主节点挂掉，从节点继续服务。 集群模式2：Master-Slave：主从同步数据与Redis的主从同步差不多 集群模式3：多主集群同步部署模式与2差不多，写入是可以任意节点进行写入。 集群模式4：多主集群转发部署模式元数据共享，当查找数据的时候，就会判断消息的元数据是否存在，存在则返回，否则就去问其他的消费者。 集群模式5：Master-Slave与Broker-Cluster组合方案集群模式的总结 消息共享 消息同步 元数据共享 1.4 消息的高可靠 消息的传输：协议保证 消息的存储：持久化 1.5 MQ的使用场景流量消峰、应用解耦、异步处理 在说这个部分的时候，跟自己的业务结合一起去阐述三个场景。 二、RabbitMQ2.1 RabbitMQ安装首先可以进入RabbitMQ官网上查看 RabbitMQ Erlang版本要求 Linux安装视频：https://www.bilibili.com/video/BV1dX4y1V73G?p=9 Windows安装文章：https://www.cnblogs.com/saryli/p/9729591.html Docker安装视频：https://www.bilibili.com/video/BV1dX4y1V73G?p=10 端口15672：通过 http://serverip:15672 访问 RabbitMQ 的 Web 管理界面，默认用户名密码都是 guest端口5672,5671（ used by AMQP 0-9-1 and 1.0 clients without and with TLS ）由AMQP0-9-1和1.0客户机使用，不带和带TLS端口25672：用于节点间和CLI工具通信（Erlang分发服务器端口），并且是从动态范围分配（默认情况下限制为一个端口，计算为AMQP端口+20000） 2.2 RabbitMQ的核心概念生产者、交换机、队列、消费者","link":"/p/16a9afcf.html"}],"tags":[{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"},{"name":"Backblaze","slug":"Backblaze","link":"/tags/Backblaze/"},{"name":"CloudFlare","slug":"CloudFlare","link":"/tags/CloudFlare/"},{"name":"Mysql","slug":"Mysql","link":"/tags/Mysql/"},{"name":"RabbitMQ","slug":"RabbitMQ","link":"/tags/RabbitMQ/"},{"name":"分布式事务","slug":"分布式事务","link":"/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"},{"name":"itextpdf","slug":"itextpdf","link":"/tags/itextpdf/"},{"name":"thymeleaf","slug":"thymeleaf","link":"/tags/thymeleaf/"},{"name":"html2pdf","slug":"html2pdf","link":"/tags/html2pdf/"},{"name":"人大金仓,Postgresql","slug":"人大金仓-Postgresql","link":"/tags/%E4%BA%BA%E5%A4%A7%E9%87%91%E4%BB%93-Postgresql/"},{"name":"正则表达式","slug":"正则表达式","link":"/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"VSCODE","slug":"VSCODE","link":"/tags/VSCODE/"},{"name":"问卷星","slug":"问卷星","link":"/tags/%E9%97%AE%E5%8D%B7%E6%98%9F/"},{"name":"油猴脚本","slug":"油猴脚本","link":"/tags/%E6%B2%B9%E7%8C%B4%E8%84%9A%E6%9C%AC/"},{"name":"vue3","slug":"vue3","link":"/tags/vue3/"}],"categories":[{"name":"翻车日志","slug":"翻车日志","link":"/categories/%E7%BF%BB%E8%BD%A6%E6%97%A5%E5%BF%97/"},{"name":"博客日志","slug":"博客日志","link":"/categories/%E5%8D%9A%E5%AE%A2%E6%97%A5%E5%BF%97/"},{"name":"开发日志","slug":"开发日志","link":"/categories/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"},{"name":"学习笔记","slug":"学习笔记","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"科技人生","slug":"科技人生","link":"/categories/%E7%A7%91%E6%8A%80%E4%BA%BA%E7%94%9F/"}],"pages":[{"title":"归档","text":"","link":"/archives/index.html"},{"title":"关于","text":"关于我我是一名后端开发工程师，喜欢折腾，目前大四。","link":"/about/index.html"},{"title":"友情链接","text":"","link":"/links/index.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"关于","text":"","link":"/about/index%20-%20%E5%89%AF%E6%9C%AC.html"},{"title":"标签","text":"","link":"/tags/index.html"},{"title":"即刻短文","text":"","link":"/says/index.html"}]}